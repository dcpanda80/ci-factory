<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://nant.sf.net/schemas/nant.xsd" name="Scratch.Lib">

  <macrodef name="play">
    <attributes>
      <attribute name="dir" type="string" require="true"/>
    </attributes>
    <elements>
      <element name="fileset" type="NAnt.Core.Types.FileSet"/>
    </elements>
    <elementgroups>
      <elementgroup name="includes" type="NAnt.Core.Types.FileSet.Include" elementname="include"/>
    </elementgroups>
    <sequential>
      <fileset id="files">
        <elementgroup name="includes"/>
      </fileset>
      <echo message="${fileset::include-count('files')}"/>
      <echo message="${fileset::file-count('files')}"/>
      <echo message="${fileset::get-name-at-index('files', 0)}"/>
      <foreach item="File" property="file">
        <in>
          <items refid="files"/>
        </in>
        <do>
          <echo message="${file} exists ${file::exists(file)}"/>
        </do>
      </foreach>
      <copy todir="${dir}" verbose="true">
        <fileset refid="files"/>
      </copy>
    </sequential>
  </macrodef>
  
  <!--
  <property name="ProductDirectory" value="C:\Projects\dod.ahlta\Current\Product"/>
  <property name="ShouldFix" value="true"/>
  -->
  <target name="FixProjectBindings" >
    <property name="ShouldFix" value="false" overwrite="false"/>
    <fileset id="ProjectFiles">
      <include name="${ProductDirectory}\**\*.*proj"/>
    </fileset>

    <property name="count" value="0"/>

    <foreach item="File" property="ProjectFile.Path">
      <in>
        <items refid="ProjectFiles" />
      </in>
      <do>
        <property name="AreProjectBindingsCorrect" value="${vsproject::are-bindings-correct(ProjectFile.Path)}"/>
        <ifnot test="${AreProjectBindingsCorrect}">
          <echo message="${ProjectFile.Path} needs it's bindings fixed"/>
          <property name="count" value="${int::parse(count) + 1}"/>
          <if test="${ShouldFix}">
            <property name="SourceControl.CheckOut.File" value="${ProjectFile.Path}"/>
            <call target="SourceControl.CheckOut"/>
            <function execute="${vsproject::fix-bindings(ProjectFile.Path)}"/>
          </if>
        </ifnot>

        <property name="VSPSCCFile.Path" value="${ProjectFile.Path}.vspscc"/>
        <loadfile encoding="utf-8" file="${VSPSCCFile.Path}" property="VSPSCCFile.Contents" />

        <loglevel level="None">
          <do>
            <property name="VSPSCCFile_PROJECT_FILE_RELATIVE_PATH_Actual" value="not set"/>
            <regex input="${VSPSCCFile.Contents}" pattern="&quot;PROJECT_FILE_RELATIVE_PATH&quot;\s+=\s+&quot;(?'VSPSCCFile_PROJECT_FILE_RELATIVE_PATH_Actual'.*)&quot;" failonerror="false"/>

            <property name="VSPSCCFile.PROJECT_FILE_RELATIVE_PATH.Expected" value="relative:${string::replace(string::replace(path::get-directory-name(ProjectFile.Path), ProductDirectory + '\', ''), '\', '\\')}"/>

            <property name="VSPSCCFile_SOURCE_CONTROL_SETTINGS_PROVIDER_Actual" value="not set"/>
            <regex input="${VSPSCCFile.Contents}" pattern="&quot;SOURCE_CONTROL_SETTINGS_PROVIDER&quot;\s+=\s+&quot;(?'VSPSCCFile_SOURCE_CONTROL_SETTINGS_PROVIDER_Actual'.*)&quot;" failonerror="false"/>

            <property name="VSPSCCFile.SOURCE_CONTROL_SETTINGS_PROVIDER.Expected" value="PROVIDER"/>
          </do>
        </loglevel>

        <ifnot test="${VSPSCCFile.SOURCE_CONTROL_SETTINGS_PROVIDER.Expected == VSPSCCFile_SOURCE_CONTROL_SETTINGS_PROVIDER_Actual and VSPSCCFile.PROJECT_FILE_RELATIVE_PATH.Expected == VSPSCCFile_PROJECT_FILE_RELATIVE_PATH_Actual}" >
          <echo message="${VSPSCCFile.Path} needs it's bindings fixed"/>
          <property name="count" value="${int::parse(count) + 1}"/>
          <if test="${ShouldFix}">
            <property name="SourceControl.CheckOut.File" value="${VSPSCCFile.Path}"/>
            <call target="SourceControl.CheckOut"/>

            <applyfilter propertyname="VSPSCCFile.Contents" >
              <text expand="true"><![CDATA[${VSPSCCFile.Contents}]]></text>
              <filterchain>
                <regexreplace replacment="$+${VSPSCCFile.PROJECT_FILE_RELATIVE_PATH.Expected}&quot;" pattern="(&quot;PROJECT_FILE_RELATIVE_PATH&quot;\s+=\s+&quot;).*" lines="1" />
              </filterchain>
            </applyfilter>

            <applyfilter propertyname="VSPSCCFile.Contents" >
              <text expand="true"><![CDATA[${VSPSCCFile.Contents}]]></text>
              <filterchain>
                <regexreplace replacment="$+${VSPSCCFile.SOURCE_CONTROL_SETTINGS_PROVIDER.Expected}&quot;" pattern="(&quot;SOURCE_CONTROL_SETTINGS_PROVIDER&quot;\s+=\s+&quot;).*" lines="1" />
              </filterchain>
            </applyfilter>

            <echo message="${VSPSCCFile.Contents}" file="${VSPSCCFile.Path}"/>
          </if>
        </ifnot>
      </do>
    </foreach>

    <ifthenelse test="${ShouldFix}">
      <then>
        <echo message="${count} projects were fixed."/>
      </then>
      <else>
        <echo message="${count} projects need to be fixed."/>
      </else>
    </ifthenelse>

  </target>

  <script language="C#" prefix="vsproject">
    <imports >
      <import namespace="System.Xml"/>
      <import namespace="System.Text"/>
      <import namespace="System.Collections.Generic"/>
    </imports >
    <code>
      <![CDATA[                 
					
          [Function("are-bindings-correct")]
          public bool AreBindingsCorrect(string projectFilePath)
          {
              XmlDocument xd = new XmlDocument();
              xd.PreserveWhitespace=true;
              xd.Load(projectFilePath);
              
              XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xd.NameTable);
              namespaceManager.AddNamespace("b", @"http://schemas.microsoft.com/developer/msbuild/2003");

              List<string> Queries = new List<string>();
              Queries.Add("//b:SccProjectName");
              Queries.Add("//b:SccLocalPath");
              Queries.Add("//b:SccAuxPath");
              Queries.Add("//b:SccProvider");

              foreach (string Query in Queries)
              {
                  XmlNode Node = null;
                  Node = xd.SelectSingleNode(Query, namespaceManager);
                  if (Node == null || Node.InnerText != "SAK")
                      return false;
              }

              return true;
          }
          
          [Function("fix-bindings")]
          public void FixBindings(string projectFilePath)
          {
              XmlDocument xd = new XmlDocument();
              xd.PreserveWhitespace = true;
              xd.Load(projectFilePath);

              XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xd.NameTable);
              namespaceManager.AddNamespace("b", @"http://schemas.microsoft.com/developer/msbuild/2003");

              XmlNode ParentNode = xd.SelectSingleNode(@"/b:Project/b:PropertyGroup[boolean(@Condition) = false]", namespaceManager);

              Dictionary<string, string> Queries = new Dictionary<string, string>();
              Queries.Add("SccProjectName", "//b:SccProjectName");
              Queries.Add("SccLocalPath", "//b:SccLocalPath");
              Queries.Add("SccAuxPath", "//b:SccAuxPath");
              Queries.Add("SccProvider", "//b:SccProvider");

              foreach (KeyValuePair<string, string> Pair in Queries)
              {
                  string Query = Pair.Value;
                  XmlNode Node = null;
                  Node = xd.SelectSingleNode(Query, namespaceManager);
                  if (Node != null || Node.InnerText != "SAK")
                      Node.InnerText = "SAK";
                  if (Node == null)
                  {
                      XmlElement Element = xd.CreateElement(Pair.Key);
                      Element.InnerText = "SAK";
                      ParentNode.AppendChild(Element);
                  }
              }

              xd.Save(projectFilePath);
          }
          
			]]>
    </code>
  </script>


  <!--
  <property name="ProductDirectory" value="C:\Projects\dod.ahlta\Current\Product"/>
  <property name="SolutionFile.Path" value="${ProductDirectory}\dod.ahlta.sln"/>
  <property name="ShouldFix" value="true"/>
  -->
  <target name="FixSolutionBindings">
    <property name="ShouldFix" value="false" overwrite="false"/>
    
    <loadfile encoding="utf-8" file="${SolutionFile.Path}" property="SolutionFile.Contents" >
      <filterchain>
        <regexreplace replacment="$+." pattern="(SccLocalPath\d+\s+=\s+).*" lines="1" />
      </filterchain>
    </loadfile>

    <applyfilter propertyname="SolutionFile.Contents" >
      <text expand="true"><![CDATA[${SolutionFile.Contents}]]></text>
      <filterchain>
        <regexreplace replacment="= ${CCNetProject}.sln\n" pattern="=\s+${CCNetProject}.sln\r\n\s+SccProjectName\d+\s+=\s+.*\r\n" lines="2" />
      </filterchain>
    </applyfilter>

    <ifthenelse test="${ShouldFix}">
      <then>
        <property name="SourceControl.CheckOut.File" value="${SolutionFile.Path}"/>
        <call target="SourceControl.CheckOut"/>
        <echo message="${SolutionFile.Contents}" file="${SolutionFile.Path}"/>
      </then>
      <else>
        <echo message="${SolutionFile.Contents}"/>
      </else>
    </ifthenelse>
  </target>

  <target name="ReplaceNAntHeaders">
    <fileset id="files">
      <include name="C:\Projects\CI Factory\Current\Product\Production\CIScript\CIScript.Core\**\*.cs"/>
    </fileset>

    <largeproperty name="OldHeader">
      <value xml="false">
        <![CDATA[
// Copyright (C) 2001-2003 Gerry Shaw
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Gerry Shaw (gerry_shaw@yahoo.com)
]]>
      </value>
    </largeproperty>

    <foreach item="File" property="SourceFile">
      <in>
        <items refid="files" />
      </in>
      <do>
        <loadfile encoding="utf-8" file="${SourceFile}" property="Contents" >
          <filterchain>
            <replacestring from="NAnt" to="CIScript" />
            <replacestring from="nAnt" to="ciScript" />
            <replacestring from="Nant" to="CIscript" />
            <replacestring from="nant" to="ciscript" />

            <replacestring from="// This program is free software; you can redistribute it and/or modify" to="// Copyright (c) 2007 Jay Flowers (jay.flowers@gmail.com)" />
            <replacestring from="// it under the terms of the GNU General Public License as published by" to="//" />
            <replacestring from="// the Free Software Foundation; either version 2 of the License, or" to="//" />
            <replacestring from="// (at your option) any later version." to="//" />
            <replacestring from="// This program is distributed in the hope that it will be useful," to="//" />
            <replacestring from="// but WITHOUT ANY WARRANTY; without even the implied warranty of" to="//" />
            <replacestring from="// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the" to="//" />
            <replacestring from="// GNU General Public License for more details." to="//" />
            <replacestring from="// You should have received a copy of the GNU General Public License" to="//" />
            <replacestring from="// along with this program; if not, write to the Free Software" to="//" />
            <replacestring from="// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA" to="//" />
          </filterchain>
        </loadfile>
        <write file="${SourceFile}">
          <text expand="true" xml="false"><![CDATA[${Contents}]]></text>
          <filterchain>
            <regexreplace replacment="" pattern="(//\r\n)+" lines="12" />
          </filterchain>
        </write>
      </do>
    </foreach>
  </target>

  <target name="ConvertVBToCSharp">
    <copy todir="C:\Temp\" overwrite="true" newext=".cs">
      <fileset basedir="C:\Projects\CI Factory\Current\Product\Production\Nant">
        <include name="Common.Tasks\**\*.vb"/>
      </fileset>
      <filterchain>
        <codeconvert to="CSharp" from="VBNet" />
      </filterchain>
    </copy>
  </target>

  <target name="FixUpProjectInfo">
    <property name="Versioning.FixUp.ProjectFile.FileSet" value="My.Versioning.FixUp.ProjectFile.FileSet"/>

    <fileset id="${Versioning.FixUp.ProjectFile.FileSet}">
      <include name="${ProductionDirectory}\**\*.csproj"/>
      <include name="${ProductionDirectory}\**\*.vbproj"/>
    </fileset>
    <call target="Versioning.FixUp"/>
  </target>


</project>